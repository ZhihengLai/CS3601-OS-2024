{
    "sourceFile": "kernel/ipc/connection.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1703081837220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1703081837220,
            "name": "Commit-0",
            "content": "/*\n * Copyright (c) 2023 Institute of Parallel And Distributed Systems (IPADS), Shanghai Jiao Tong University (SJTU)\n * Licensed under the Mulan PSL v2.\n * You can use this software according to the terms and conditions of the Mulan PSL v2.\n * You may obtain a copy of Mulan PSL v2 at:\n *     http://license.coscl.org.cn/MulanPSL2\n * THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR\n * PURPOSE.\n * See the Mulan PSL v2 for more details.\n */\n\n/*\n * Inter-**Process** Communication.\n *\n * connection: between a client cap_group and a server cap_group (two processes)\n * We store connection cap in a process' cap_group, so each thread in it can\n * use that connection.\n *\n * A connection (cap) can be used by any thread in the client cap_group.\n * A connection will be **only** served by one server thread while\n * one server thread may serve multiple connections.\n *\n * There is one PMO_SHM binding with one connection.\n *\n * Connection can only serve one IPC request at the same time.\n * Both user and kernel should check the \"busy_state\" of a connection.\n * Besides, register thread can also serve one registration request for one\n * time.\n *\n * Since a connection can only be shared by client threads in the same process,\n * a connection has only-one **badge** to identify the process.\n * During ipc_call, the kernel can set **badge** as an argument in register.\n *\n * Overview:\n * **IPC registration (control path)**\n *  - A server thread (S1) invokes **sys_register_server** with\n *    a register_cb_thread (S2)\n *\n *  - A client thread (C) invokes **sys_register_client(S1)**\n *\t- invokes (switches) to S2 actually\n *  - S2 invokes **sys_ipc_register_cb_return** with a handler_thread (S3)\n *\t- S3 will serve IPC requests later\n *\t- switches back to C (finish the IPC registration)\n *\n * **IPC call/reply (data path)**\n *  - C invokes **sys_ipc_call**\n *\t- switches to S3\n *  - S3 invokes **sys_ipc_return**\n *\t- switches to C\n */\n\n#include <arch/sync.h>\n#include <common/errno.h>\n#include <ipc/connection.h>\n#include <irq/irq.h>\n#include <mm/kmalloc.h>\n#include <mm/uaccess.h>\n#include <object/memory.h>\n#include <sched/context.h>\n#include <common/util.h>\n\n/*\n * Overall, a server thread that declares a serivce with this interface\n * should specify:\n * @ipc_routine (the real ipc service routine entry),\n * @register_thread_cap (another server thread for handling client\n * registration), and\n * @destructor (one routine invoked when some connnection is closed).\n */\nstatic int register_server(struct thread *server, unsigned long ipc_routine,\n                           cap_t register_thread_cap, unsigned long destructor)\n{\n        struct ipc_server_config *config;\n        struct thread *register_cb_thread;\n        struct ipc_server_register_cb_config *register_cb_config;\n\n        BUG_ON(server == NULL);\n        if (server->general_ipc_config != NULL) {\n                kdebug(\"A server thread can only invoke **register_server** once!\\n\");\n                return -EINVAL;\n        }\n\n        /*\n         * Check the passive thread in server for handling\n         * client registration.\n         */\n        register_cb_thread =\n                obj_get(current_cap_group, register_thread_cap, TYPE_THREAD);\n        if (!register_cb_thread) {\n                kdebug(\"A register_cb_thread is required.\\n\");\n                return -ECAPBILITY;\n        }\n\n        if (register_cb_thread->thread_ctx->type != TYPE_REGISTER) {\n                kdebug(\"The register_cb_thread should be TYPE_REGISTER!\\n\");\n                obj_put(register_cb_thread);\n                return -EINVAL;\n        }\n\n        config = kmalloc(sizeof(*config));\n\n        /*\n         * @ipc_routine will be the real ipc_routine_entry.\n         * No need to validate such address because the server just\n         * kill itself if the address is illegal.\n         */\n        /* LAB 4 TODO BEGIN (exercise 7) */\n        /* Complete the config structure, replace xxx with actual values */\n        /* Record the ipc_routine_entry  */\n        config->declared_ipc_routine_entry = ipc_routine;\n\n        /* Record the registration cb thread */\n        config->register_cb_thread = register_cb_thread;\n        /* LAB 4 TODO END (exercise 7) */\n\n        register_cb_config = kmalloc(sizeof(*register_cb_config));\n        register_cb_thread->general_ipc_config = register_cb_config;\n\n        /*\n         * This lock will be used to prevent concurrent client threads\n         * from registering.\n         * In other words, a register_cb_thread can only serve\n         * registration requests one-by-one.\n         */\n        lock_init(&register_cb_config->register_lock);\n\n        /* Record PC as well as the thread's initial stack (SP). */\n        register_cb_config->register_cb_entry =\n                arch_get_thread_next_ip(register_cb_thread);\n        register_cb_config->register_cb_stack =\n                arch_get_thread_stack(register_cb_thread);\n        register_cb_config->destructor = destructor;\n        obj_put(register_cb_thread);\n\n#if defined(CHCORE_ARCH_AARCH64)\n        /* The following fence can ensure: the config related data,\n         * e.g., the register_lock, can been seen when\n         * server->general_ipc_config is set.\n         */\n        smp_mb();\n#else\n        /* TSO: the fence is not required. */\n#endif\n\n        /*\n         * The last step: fill the general_ipc_config.\n         * This field is also treated as the whether the server thread\n         * declares an IPC service (or makes the service ready).\n         */\n        server->general_ipc_config = config;\n\n        return 0;\n}\n\nvoid connection_deinit(void *conn)\n{\n        /* For now, no de-initialization is required */\n}\n\n/* Just used for storing the results of function create_connection */\nstruct client_connection_result {\n        cap_t client_conn_cap;\n        cap_t server_conn_cap;\n        cap_t server_shm_cap;\n        struct ipc_connection *conn;\n};\n\nstatic int get_pmo_size(cap_t pmo_cap)\n{\n        struct pmobject *pmo;\n        int size;\n\n        pmo = obj_get(current_cap_group, pmo_cap, TYPE_PMO);\n        if (!pmo) {\n                kdebug(\"invalid pmo in %s\", __func__);\n                return -ECAPBILITY;\n        }\n\n        size = pmo->size;\n        obj_put(pmo);\n\n        return size;\n}\n\n/*\n * The function will create an IPC connection and initialize the client side\n * information. (used in sys_register_client)\n *\n * The server (register_cb_thread) will initialize the server side information\n * later (in sys_ipc_register_cb_return).\n */\nstatic int create_connection(struct thread *client, struct thread *server,\n                             int shm_cap_client, unsigned long shm_addr_client,\n                             struct client_connection_result *res)\n{\n        cap_t shm_cap_server;\n        struct ipc_connection *conn;\n        int ret = 0;\n        cap_t conn_cap = 0, server_conn_cap = 0;\n        int shm_size;\n\n        BUG_ON((client == NULL) || (server == NULL));\n\n        shm_size = get_pmo_size(shm_cap_client);\n        if (shm_size < 0)\n                return -ECAPBILITY;\n\n        /*\n         * Copy the shm_cap to the server.\n         *\n         * It is reasonable to count the shared memory usage on the client.\n         * So, a client should prepare the shm and tell the server.\n         */\n        shm_cap_server =\n                cap_copy(current_cap_group, server->cap_group, shm_cap_client);\n\n        /* Create struct ipc_connection */\n        conn = obj_alloc(TYPE_CONNECTION, sizeof(*conn));\n        if (!conn) {\n                ret = -ENOMEM;\n                goto out_fail;\n        }\n\n        /* Initialize the connection (begin).\n         *\n         * Note that now client is applying to build the connection\n         * instead of issuing an IPC.\n         */\n        conn->state = CONN_INCOME_STOPPED;\n        conn->current_client_thread = client;\n        /*\n         * The register_cb_thread in server will assign the\n         * server_handler_thread later.\n         */\n        conn->server_handler_thread = NULL;\n        /*\n         * The badge is now generated by the process who creates the client\n         * thread. Usually, the process is the procmgr user-space service.\n         * The badge needs to be unique.\n         *\n         * Before a process exits, it needs to close the connection with\n         * servers. Otherwise, a later process may pretend to be it\n         * because the badge is based on PID (if a PID is reused,\n         * the same badge occur).\n         * Or, the kernel should notify the server to close the\n         * connections when some client exits.\n         */\n        conn->client_badge = current_cap_group->badge;\n\n        /* LAB 4 TODO BEGIN (exercise 7) */\n        /* Complete the following fields of shm, replace xxx with actual values */\n        // conn->shm.client_shm_uaddr = xxx;\n        // conn->shm.shm_size = xxx;\n        // conn->shm.shm_cap_in_client = xxx;\n        // conn->shm.shm_cap_in_server = xxx;\n        conn->shm.client_shm_uaddr = shm_addr_client;\n        conn->shm.shm_size = shm_size;\n        conn->shm.shm_cap_in_client = shm_cap_client;\n        conn->shm.shm_cap_in_server = shm_cap_server;\n        /* LAB 4 TODO END (exercise 7) */\n\n        lock_init(&conn->ownership);\n        /* Initialize the connection (end) */\n\n        /* After initializing the object,\n         * give the ipc_connection (cap) to the client.\n         */\n        conn_cap = cap_alloc(current_cap_group, conn);\n        if (conn_cap < 0) {\n                ret = conn_cap;\n                goto out_free_obj;\n        }\n\n        /* Give the ipc_connection (cap) to the server */\n        server_conn_cap =\n                cap_copy(current_cap_group, server->cap_group, conn_cap);\n        if (server_conn_cap < 0) {\n                ret = server_conn_cap;\n                goto out_free_cap;\n        }\n\n        /* Preapre the return results */\n        res->client_conn_cap = conn_cap;\n        res->server_conn_cap = server_conn_cap;\n        res->server_shm_cap = shm_cap_server;\n        res->conn = conn;\n\n        return 0;\n\nout_free_cap:\n        cap_free(current_cap_group, conn_cap);\n        conn = NULL;\nout_free_obj:\n        obj_free(conn);\nout_fail:\n        return ret;\n}\n\n/*\n * Grap the ipc lock before doing any modifications including\n * modifing the conn or sending the caps.\n */\nstatic inline int grab_ipc_lock(struct ipc_connection *conn)\n{\n        struct thread *target;\n        struct ipc_server_handler_config *handler_config;\n\n        target = conn->server_handler_thread;\n        handler_config =\n                (struct ipc_server_handler_config *)target->general_ipc_config;\n\n        /*\n         * Grabing the ipc_lock can ensure:\n         * First, avoid invoking the same handler thread.\n         * Second, also avoid using the same connection.\n         *\n         * perf in Qemu: lock & unlock (without contention) just takes\n         * about 20 cycles on x86_64.\n         */\n\n        /* Use try-lock, otherwise deadlock may happen\n         * deadlock: T1: ipc-call -> Server -> resched to T2: ipc-call\n         *\n         * Although lock is added in user-ipc-lib, a buggy app may dos\n         * the kernel.\n         */\n\n        if (try_lock(&handler_config->ipc_lock) != 0)\n                return -EIPCRETRY;\n\n        return 0;\n}\n\nstatic inline int release_ipc_lock(struct ipc_connection *conn)\n{\n        struct thread *target;\n        struct ipc_server_handler_config *handler_config;\n\n        target = conn->server_handler_thread;\n        handler_config =\n                (struct ipc_server_handler_config *)target->general_ipc_config;\n\n        unlock(&handler_config->ipc_lock);\n\n        return 0;\n}\n\nstatic void ipc_thread_migrate_to_server(struct ipc_connection *conn,\n                                     unsigned long shm_addr, size_t shm_size, unsigned int cap_num)\n{\n        struct thread *target;\n        struct ipc_server_handler_config *handler_config;\n\n        target = conn->server_handler_thread;\n        handler_config =\n                (struct ipc_server_handler_config *)target->general_ipc_config;\n\n        /*\n         * Note that a server ipc handler thread can be assigned to multiple\n         * connections.\n         * So, it is necessary to record which connection is active.\n         */\n        handler_config->active_conn = conn;\n\n        /*\n         * Note that multiple client threads may share a same connection.\n         * So, it is necessary to record which client thread is active.\n         * Then, the server can transfer the control back to it after finishing\n         * the IPC.\n         */\n        conn->current_client_thread = current_thread;\n\n        /* Mark current_thread as TS_WAITING */\n        current_thread->thread_ctx->state = TS_WAITING;\n\n        /* Pass the scheduling context */\n        target->thread_ctx->sc = current_thread->thread_ctx->sc;\n\n        /* Set the target thread SP/IP/arguments */\n        /* LAB 4 TODO BEGIN (exercise 7) */\n        /*\n         * Complete the arguments in the following function calls,\n         * replace xxx with actual arguments.\n         */\n\n        /* Note: see how stack address and ip are get in sys_ipc_register_cb_return */\n        /*              \n                handler_config->ipc_routine_entry =\n                arch_get_thread_next_ip(ipc_server_handler_thread);\n                handler_config->ipc_routine_stack =\n                arch_get_thread_stack(ipc_server_handler_thread);\n        */\n        arch_set_thread_stack(target, handler_config->ipc_routine_stack);\n        arch_set_thread_next_ip(target, handler_config->ipc_routine_entry);\n\n        /* see server_handler type in uapi/ipc.h */\n        arch_set_thread_arg0(target, shm_addr);\n        arch_set_thread_arg1(target, shm_size);\n        arch_set_thread_arg2(target, cap_num);\n        arch_set_thread_arg3(target, conn->client_badge);\n        /* LAB 4 TODO END (exercise 7) */\n\n        set_thread_arch_spec_state_ipc(target);\n\n        /* Switch to the target thread */\n        sched_to_thread(target);\n\n        /* Function never return */\n        BUG_ON(1);\n}\n\nstatic void thread_migrate_to_client(struct thread *client,\n                                     unsigned long ret_value)\n{\n        /* Set return value for the target thread */\n        arch_set_thread_return(client, ret_value);\n\n        /* Switch to the client thread */\n        sched_to_thread(client);\n\n        /* Function never return */\n        BUG_ON(1);\n}\n\nstruct client_shm_config {\n        cap_t shm_cap;\n        unsigned long shm_addr;\n};\n\n/* IPC related system calls */\n\nint sys_register_server(unsigned long ipc_routine,\n                        cap_t register_thread_cap,\n                        unsigned long destructor)\n{\n        return register_server(\n                current_thread, ipc_routine, register_thread_cap, destructor);\n}\n\ncap_t sys_register_client(cap_t server_cap, unsigned long shm_config_ptr)\n{\n        struct thread *client;\n        struct thread *server;\n\n        /*\n         * No need to initialize actually.\n         * However, fbinfer will complain without zeroing because\n         * it cannot tell copy_from_user.\n         */\n        struct client_shm_config shm_config = {0};\n        int r;\n        struct client_connection_result res;\n\n        struct ipc_server_config *server_config;\n        struct thread *register_cb_thread;\n        struct ipc_server_register_cb_config *register_cb_config;\n\n        client = current_thread;\n\n        server = obj_get(current_cap_group, server_cap, TYPE_THREAD);\n        if (!server) {\n                r = -ECAPBILITY;\n                goto out_fail;\n        }\n\n        server_config =\n                (struct ipc_server_config *)(server->general_ipc_config);\n        if (!server_config) {\n                r = -EIPCRETRY;\n                goto out_fail;\n        }\n\n        /*\n         * Locate the register_cb_thread first.\n         * And later, directly transfer the control flow to it\n         * for finishing the registration.\n         *\n         * The whole registration procedure:\n         * client thread -> server register_cb_thread -> client threrad\n         */\n        register_cb_thread = server_config->register_cb_thread;\n        register_cb_config =\n                (struct ipc_server_register_cb_config\n                         *)(register_cb_thread->general_ipc_config);\n\n        /* Acquiring register_lock: avoid concurrent client registration.\n         *\n         * Use try_lock instead of lock since the unlock operation is done by\n         * another thread and ChCore does not support mutex.\n         * Otherwise, dead lock may happen.\n         */\n        if (try_lock(&register_cb_config->register_lock) != 0) {\n                r = -EIPCRETRY;\n                goto out_fail;\n        }\n\n        /* Validate the user addresses before accessing them */\n        if (check_user_addr_range(shm_config_ptr, sizeof(shm_config) != 0)) {\n                r = -EINVAL;\n                goto out_fail_unlock;\n        }\n\n        copy_from_user((void *)&shm_config, (void *)shm_config_ptr, sizeof(shm_config));\n\n\n        /* Map the pmo of the shared memory */\n        r = map_pmo_in_current_cap_group(\n                shm_config.shm_cap, shm_config.shm_addr, VMR_READ | VMR_WRITE);\n\n        if (r != 0) {\n                goto out_fail_unlock;\n        }\n\n        /* Create the ipc_connection object */\n        r = create_connection(\n                client, server, shm_config.shm_cap, shm_config.shm_addr, &res);\n\n        if (r != 0) {\n                goto out_fail_unlock;\n        }\n\n        /* Record the connection cap of the client process */\n        register_cb_config->conn_cap_in_client = res.client_conn_cap;\n        register_cb_config->conn_cap_in_server = res.server_conn_cap;\n        /* Record the server_shm_cap for current connection */\n        register_cb_config->shm_cap_in_server = res.server_shm_cap;\n\n        /* Mark current_thread as TS_WAITING */\n        current_thread->thread_ctx->state = TS_WAITING;\n\n        /* LAB 4 TODO BEGIN (exercise 7) */\n        /* Set target thread SP/IP/arg, replace xxx with actual arguments */\n        /* Note: see how stack address and ip are get in sys_register_server */\n        arch_set_thread_stack(register_cb_thread, register_cb_config->register_cb_stack);\n        arch_set_thread_next_ip(register_cb_thread, register_cb_config->register_cb_entry);\n\n        /*\n         * Note: see the parameter of register_cb function defined\n         * in user/chcore-libc/musl-libc/src/chcore-port/ipc.c\n         */\n        /* set the first parameter of call-back thread, which is also the parameter of register_cb. in connection.h, it says \n        \" Record the argument from the server thread\"  */\n        arch_set_thread_arg0(register_cb_thread, server_config->declared_ipc_routine_entry);\n        /* LAB 4 TODO END (exercise 7) */\n\n        obj_put(server);\n\n        /* Pass the scheduling context */\n        register_cb_thread->thread_ctx->sc = current_thread->thread_ctx->sc;\n\n        /* On success: switch to the cb_thread of server  */\n        sched_to_thread(register_cb_thread);\n\n        /* Never return */\n        BUG_ON(1);\n\nout_fail_unlock:\n        unlock(&register_cb_config->register_lock);\nout_fail: /* Maybe EAGAIN */\n        if (server)\n                obj_put(server);\n        return r;\n}\n\nstatic int ipc_send_cap(struct thread *target_thread, unsigned int cap_num)\n{\n        int i, r = 0;\n        cap_t dest_cap;\n        cap_t *src_cap_buf, *dest_cap_buf;\n        struct cap_group *target_cap_group;\n\n        if (cap_num >= MAX_CAP_TRANSFER) {\n                r = -EINVAL;\n                goto out_fail;\n        }\n\n        src_cap_buf = current_thread->cap_buffer;\n        dest_cap_buf = target_thread->cap_buffer;\n        target_cap_group = target_thread->cap_group;\n\n        for (i = 0; i < cap_num; i++) {\n                dest_cap = cap_copy(current_cap_group, target_cap_group,\n                                    src_cap_buf[i]);\n                if (dest_cap < 0) {\n                        r = dest_cap;\n                        goto out_free_cap;\n                }\n                dest_cap_buf[i] = dest_cap;\n        }\n\n        return 0;\n\nout_free_cap:\n        for (--i; i >= 0; i--)\n                cap_free(target_cap_group, dest_cap_buf[i]);\nout_fail:\n        return r;\n}\n\n/* Issue an IPC request */\nunsigned long sys_ipc_call(cap_t conn_cap, unsigned int cap_num)\n{\n        struct ipc_connection *conn;\n        int r = 0;\n\n        if (cap_num > MAX_CAP_TRANSFER) {\n                return -EINVAL;\n        }\n\n        conn = obj_get(current_cap_group, conn_cap, TYPE_CONNECTION);\n        if (unlikely(!conn)) {\n                return -ECAPBILITY;\n        }\n\n        if (try_lock(&conn->ownership) == 0) {\n                /*\n                 * Succeed in locking.\n                 * Continue IPC call only when the connection state is VALID.\n                 */\n                if (conn->state != CONN_VALID) {\n                        unlock(&conn->ownership);\n                        obj_put(conn);\n                        return -EINVAL;\n                }\n        } else {\n                /* Fails to lock the connection */\n                obj_put(conn);\n\n                if (current_thread->thread_ctx->thread_exit_state == TE_EXITING) {\n                        /* The connection is locked by the recycler */\n\n                        if (current_thread->thread_ctx->type == TYPE_SHADOW) {\n                                /*\n                                 * The current thread is B in chained IPC\n                                 * (A:B:C). B will receives an Error.\n                                 * We hope B invokes sys_ipc_return to give\n                                 * the control flow back to A and unlock the\n                                 * related connection.\n                                 *\n                                 * B may do not return the control flow\n                                 * back to A. If so, A will always hang and the\n                                 * recycler (sys_recycle_cap_group) cannot lock\n                                 * the connection. Extra mechanism like timeout\n                                 * is required.\n                                 */\n                                return -ESRCH;\n                        } else {\n                                /* Current thread will be set to exited by\n                                 * the scheduler */\n                                sched();\n                                eret_to_thread(switch_context());\n                        }\n                } else {\n                        /* The connection is locked by someone else */\n                        return -EIPCRETRY;\n                }\n        }\n\n        /*\n         * try_lock may fail and returns egain.\n         * No modifications happen before locking, so the client\n         * can simply try again later.\n         */\n        if ((r = grab_ipc_lock(conn)) != 0)\n                goto out_obj_put;\n\n        if (cap_num != 0) {\n                r = ipc_send_cap(conn->server_handler_thread, cap_num);\n                if (r < 0)\n                        goto out_release_lock;\n        }\n\n        /*\n        * A shm is bound to one connection.\n        * But, the client and server can map the shm at different addresses.\n        * So, we pass the server-side shm address here.\n        */\n\n        /* Call server (handler thread) */\n        ipc_thread_migrate_to_server(conn, conn->shm.server_shm_uaddr, conn->shm.shm_size, cap_num);\n\n        BUG(\"should not reach here\\n\");\n\nout_release_lock:\n        release_ipc_lock(conn);\nout_obj_put:\n        unlock(&conn->ownership);\n        obj_put(conn);\n        return r;\n}\n\nint sys_ipc_return(unsigned long ret, unsigned int cap_num)\n{\n        struct ipc_server_handler_config *handler_config;\n        struct ipc_connection *conn;\n        struct thread *client;\n\n        /* Get the currently active connection */\n        handler_config = (struct ipc_server_handler_config *)\n                                 current_thread->general_ipc_config;\n        conn = handler_config->active_conn;\n\n        if (!conn)\n                return -EINVAL;\n\n                /*\n         * Get the client thread that issues this IPC.\n         *\n         * Note that it is **unnecessary** to set the field to NULL\n         * i.e., conn->current_client_thread = NULL.\n         */\n        client = conn->current_client_thread;\n\n        /* Step-1. check if current_thread (conn->server_handler_thread) is\n         * TE_EXITING\n         *     -> Yes: set server_handler_thread to NULL, then continue to\n         * Step-2\n         *     -> No: continue to Step-2\n         */\n        if (current_thread->thread_ctx->thread_exit_state == TE_EXITING) {\n                kdebug(\"%s:%d Step-1\\n\", __func__, __LINE__);\n\n                conn->state = CONN_INCOME_STOPPED;\n\n                current_thread->thread_ctx->thread_exit_state = TE_EXITED;\n                current_thread->thread_ctx->state = TS_EXIT;\n\n                /* Returns an error to the client */\n                ret = -ESRCH;\n        }\n\n        /* Step-2. check if client_thread is TS_EXITING\n         *     -> Yes: set current_client_thread to NULL\n         *\t  Then check if client is shadow\n         *         -> No: set client to TS_EXIT and then sched\n         *         -> Yes: return to client (it will recycle itself at next\n         *ipc_return)\n         *     -> No: return normally\n         */\n        if (client->thread_ctx->thread_exit_state == TE_EXITING) {\n                kdebug(\"%s:%d Step-2\\n\", __func__, __LINE__);\n\n                /*\n                 * Currently, a connection is assumed to belong to the client\n                 * process. So, it the client is exiting, then the connection is\n                 * useless.\n                 */\n\n                conn->state = CONN_INCOME_STOPPED;\n\n                /* If client thread is not TYPE_SHADOW, then directly mark it as\n                 * exited and reschedule.\n                 *\n                 * Otherwise, client thread is B in a chained IPC (A:B:C) and\n                 * current_thread is C. So, C returns to B and later B will\n                 * returns to A.\n                 */\n                if (client->thread_ctx->type != TYPE_SHADOW) {\n                        kdebug(\"%s:%d Step-2.0\\n\", __func__, __LINE__);\n                        handler_config->active_conn = NULL;\n\n                        current_thread->thread_ctx->state = TS_WAITING;\n\n                        current_thread->thread_ctx->sc = NULL;\n\n                        unlock(&handler_config->ipc_lock);\n\n                        unlock(&conn->ownership);\n                        obj_put(conn);\n\n                        client->thread_ctx->thread_exit_state = TE_EXITED;\n                        client->thread_ctx->state = TS_EXIT;\n\n                        sched();\n                        eret_to_thread(switch_context());\n                        /* The control flow will never go through */\n                }\n        }\n\n        if (cap_num != 0) {\n                int r = ipc_send_cap(conn->current_client_thread, cap_num);\n                if (r < 0)\n                        return r;\n        }\n\n        /* Set active_conn to NULL since the IPC will finish sooner */\n        handler_config->active_conn = NULL;\n\n        /*\n         * Return control flow (sched-context) back later.\n         * Set current_thread state to TS_WAITING again.\n         */\n        current_thread->thread_ctx->state = TS_WAITING;\n\n        /*\n         * Shadow thread should not any more use\n         * the client's scheduling context.\n         *\n         * Note that the sc of server_thread (current_thread) must be set to\n         * NULL (named OP-SET-NULL) **before** unlocking the lock.\n         * Otherwise, a following client thread may transfer its sc to the\n         * server_thread before OP-SET-NULL.\n         */\n\n        current_thread->thread_ctx->sc = NULL;\n\n        /*\n         * Release the ipc_lock to mark the server_handler_thread can\n         * serve other requests now.\n         */\n        unlock(&handler_config->ipc_lock);\n\n        unlock(&conn->ownership);\n        obj_put(conn);\n\n        /* Return to client */\n        thread_migrate_to_client(client, ret);\n        BUG(\"should not reach here\\n\");\n        __builtin_unreachable();\n}\n\nint sys_ipc_register_cb_return(cap_t server_handler_thread_cap,\n                                unsigned long server_thread_exit_routine,\n                                unsigned long server_shm_addr)\n{\n        struct ipc_server_register_cb_config *config;\n        struct ipc_connection *conn;\n        struct thread *client_thread;\n\n        struct thread *ipc_server_handler_thread;\n        struct ipc_server_handler_config *handler_config;\n        int r = -ECAPBILITY;\n\n        config = (struct ipc_server_register_cb_config *)\n                         current_thread->general_ipc_config;\n\n        if (!config)\n                goto out_fail;\n\n        conn = obj_get(\n                current_cap_group, config->conn_cap_in_server, TYPE_CONNECTION);\n\n        if (!conn)\n                goto out_fail;\n\n        /*\n         * @server_handler_thread_cap from server.\n         * Server uses this handler_thread to serve ipc requests.\n         */\n        ipc_server_handler_thread = (struct thread *)obj_get(\n                current_cap_group, server_handler_thread_cap, TYPE_THREAD);\n\n        if (!ipc_server_handler_thread)\n                goto out_fail_put_conn;\n\n        /* Map the shm of the connection in server */\n        r = map_pmo_in_current_cap_group(config->shm_cap_in_server,\n                                         server_shm_addr,\n                                         VMR_READ | VMR_WRITE);\n        if (r != 0)\n                goto out_fail_put_thread;\n\n        /* Get the client_thread that issues this registration */\n        client_thread = conn->current_client_thread;\n        /*\n         * Set the return value (conn_cap) for the client here\n         * because the server has approved the registration.\n         */\n        arch_set_thread_return(client_thread, config->conn_cap_in_client);\n\n        /*\n         * Initialize the ipc configuration for the handler_thread (begin)\n         *\n         * When the handler_config isn't NULL, it means this server handler\n         * thread has been initialized before. If so, skip the initialization.\n         * This will happen when a server uses one server handler thread for\n         * serving multiple client threads.\n         */\n        if (!ipc_server_handler_thread->general_ipc_config) {\n                handler_config = (struct ipc_server_handler_config *)kmalloc(\n                        sizeof(*handler_config));\n                ipc_server_handler_thread->general_ipc_config = handler_config;\n                lock_init(&handler_config->ipc_lock);\n\n                /*\n                 * Record the initial PC & SP for the handler_thread.\n                 * For serving each IPC, the handler_thread starts from the\n                 * same PC and SP.\n                 */\n                handler_config->ipc_routine_entry =\n                        arch_get_thread_next_ip(ipc_server_handler_thread);\n                handler_config->ipc_routine_stack =\n                        arch_get_thread_stack(ipc_server_handler_thread);\n                handler_config->ipc_exit_routine_entry =\n                        server_thread_exit_routine;\n                handler_config->destructor = config->destructor;\n        }\n        obj_put(ipc_server_handler_thread);\n        /* Initialize the ipc configuration for the handler_thread (end) */\n\n        /* Fill the server information in the IPC connection. */\n\n        /* LAB 4 TODO BEGIN (exercise 7) */\n        /* Complete the server_shm_uaddr field of shm, replace xxx with the actual value */\n        conn->shm.server_shm_uaddr = server_shm_addr;\n        /* LAB 4 TODO END (exercise 7) */\n\n        conn->server_handler_thread = ipc_server_handler_thread;\n        conn->state = CONN_VALID;\n        conn->current_client_thread = NULL;\n        conn->conn_cap_in_client = config->conn_cap_in_client;\n        conn->conn_cap_in_server = config->conn_cap_in_server;\n        obj_put(conn);\n\n        /*\n         * Return control flow (sched-context) back later.\n         * Set current_thread state to TS_WAITING again.\n         */\n        current_thread->thread_ctx->state = TS_WAITING;\n\n        unlock(&config->register_lock);\n\n        /* Register thread should not any more use the client's scheduling\n         * context. */\n        current_thread->thread_ctx->sc = NULL;\n\n        /* Finish the registration: switch to the original client_thread */\n        sched_to_thread(client_thread);\n        /* Nerver return */\n\nout_fail_put_thread:\n        obj_put(ipc_server_handler_thread);\nout_fail_put_conn:\n        obj_put(conn);\nout_fail:\n        return r;\n}\n\nvoid sys_ipc_exit_routine_return(void)\n{\n        struct ipc_server_handler_config *config;\n\n        config = (struct ipc_server_handler_config *)\n                         current_thread->general_ipc_config;\n        if (!config) {\n                goto out;\n        }\n        /*\n         * Set the server handler thread state to TS_WAITING again\n         * so that it can be migrated to from the client.\n         */\n        current_thread->thread_ctx->state = TS_WAITING;\n        kfree(current_thread->thread_ctx->sc);\n        current_thread->thread_ctx->sc = NULL;\n        unlock(&config->ipc_lock);\nout:\n        sched();\n        eret_to_thread(switch_context());\n}\n\ncap_t sys_ipc_get_cap(int index)\n{\n        if (index >= MAX_CAP_TRANSFER || index < 0) {\n                return -EINVAL;\n        }\n\n        return current_thread->cap_buffer[index];\n}\n\nint sys_ipc_set_cap(int index, cap_t cap)\n{\n        int ret = 0;\n\n        if (index >= MAX_CAP_TRANSFER || index < 0) {\n                ret = -EINVAL;\n        }\n\n        current_thread->cap_buffer[index] = cap;\n\n        return ret;\n}\n"
        }
    ]
}